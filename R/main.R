#' Converts infection probability densities to multinomial probabilities
#'
#' @param pci_list List of length 3:
#'   * `perms`: list of permutations as generated by
#'   `lapply(1:n, \code{moi_perms}, ...).
#'   * `comps`: vector of the levels of possible infection types
#'   generated by \code{generate_composition_levels}
#'   * `infs`: list of corresponding infection types as generated by
#'   \code{find_composition_level}
#' @param densities List of numeric vectors describing the probability density
#'   of each infection composition within `pci_list$perms`.
#'
#' @details Creates a matrix with each row being the mutlinomial distribution
#'   describing the probability of each infection type for a given moi. These
#'   rows are calculated by summing the probability densities in `densities`
#'   that correspond to each infection type which is contained within
#'   `pci_list$infs`.
#'
#' @return Returns a matrix with n columns, and m rows, where m is the maximum
#'   moi specified in your coccurence test..
#'
#' @examples
#' \dontrun{
#'
#'
#' obj <- new("casedetect")
#' obj@cases <- c(50, 50, 100)
#' obj@casenames <- c("a", "b", "c")
#'
#' # store all the potential compositions levels
#' comps <- generate_composition_levels(names = obj@casenames)
#'
#' # generate some permutations of infection compositions up to maxmoi
#' maxmoi <- 2
#' perms <- lapply(1:maxmoi, moi_perms, n = length(obj@casenames))
#'
#' perms
#' #> [[1]]
#' #> [,1] [,2] [,3]
#' #> [1,]    0    0    1
#' #> [2,]    1    0    0
#' #> [3,]    0    1    0

#' #> [[2]]
#' #> [,1] [,2] [,3]
#' #> [1,]    0    0    2
#' #> [2,]    1    0    1
#' #> [3,]    2    0    0
#' #> [4,]    0    1    1
#' #> [5,]    1    1    0
#' #> [6,]    0    2    0
#'
#' # and the infection types
#' infs <- find_composition_level(obj@casenames, perms)
#' infs
#' #> [[1]]
#' #> [1] "c" "a" "b"
#' #>
#' #> [[2]]
#' #> [1] "c"   "a/c" "a"   "b/c" "a/b" "b"
#'
#'
#' # create the pci_list
#' pci_list <- list("comps" = comps, "perms" = perms, "infs" = infs)
#'
#' # and also let's work out the probability densities for these infections
#' densities <- lapply(pci_list$perms, function(x){
#'   dens <- apply(x, 1, dmultinom, size = sum(x[1,]), prob = obj@cases/sum(obj@cases))
#' })
#'
#' densities
#' #> [[1]]
#' #> [1] 0.2 0.5 0.3
#' #>
#' #> [[2]]
#' #> [1] 0.04 0.20 0.25 0.12 0.30 0.09
#'
#' # and create the multinomial matrix
#' comp_dens_to_multi_dens(pci_list, densities)
#' #>         a    b    c a/b a/c  b/c a/b/c
#' #> [1,] 0.50 0.30 0.20 0.0 0.0 0.00     0
#' #> [2,] 0.25 0.09 0.04 0.3 0.2 0.12     0
#'
#' }

comp_dens_to_multi_dens <- function(pci_list, densities) {

  multi_dens <- mapply(pci_list$infs, densities, FUN = function(infs, dens) {

    dens_inf <- rep(NA, length(pci_list$comps))
    names(dens_inf) <- pci_list$comps

    for (i in pci_list$comps) {
      dens_inf[i] <- sum(dens[infs == i])
    }
    return(dens_inf)

  })

  multi_dens <- t(multi_dens)
  return(multi_dens)
}



#' Find the probabilities for the Mean MOI in the Population
#' @param obj S4 object;
#' @param maxmoi numeric; maximum MOI considered
#' @param params parameter vector; Must contain at least one value named `mu`,
#'   which is the mean muliplicity of infection. Could also contain `size` in
#'   which case negative binomial distribution is used. See details.
#'
#'  @details Using either a poisson or negative binomial distribution, the
#'   probability of drawing some series of infections is considered.
#'   In the case of where the true prevalence is known ("surveillance class),
#'   we consider the probabilities across the `0:nrow(multi_dens)` distribution.
#'   In the case that only the case distribution is known, we can only
#'   consider the probabilities across the `1:nrow(multi_dens)` distribution
#'   but will need to re-weight it to sum to 1.
#'
#'   These are used as weights to then calculate the weighted mean
#'   probability of each infection type (the columns in `multi_dens`).
#'

moi_probabilities <- function(obj, maxmoi, params){

  checkclass(obj)
  assert_numeric(maxmoi)
  assert_vector(params)

  if(inherits(obj, "surveillance")){

    x <- 0:maxmoi

    # if the params has a size parameter use a neg binomial distribution
    if ("size" %in% names(params)) {

      w <- dnbinom(x, mu = params["mu"], size = params["size"])
      w <- w / (1 - dnbinom(0, mu = params["mu"], size = params["size"]))

      # otherwise we will use the poisson
    } else {

      w <- dpois(x, lambda = params["mu"])
      w <- w / (1 - dpois(0, lambda = params["mu"]))

    }


  } else if(inherits(obj, "casedetect")){
    # range quantiles for distributions
    x <- 1:maxmoi

    # if the params has a size parameter use a neg binomial distribution
    if ("size" %in% names(params)) {

      w <- dnbinom(x, mu = params["mu"], size = params["size"])
      w <- w / (1 - dnbinom(0, mu = params["mu"], size = params["size"]))

      # otherwise we will use the poisson
    } else {

      w <- dpois(x, lambda = params["mu"])
      w <- w / (1 - dpois(0, lambda = params["mu"]))

    }
  }
  return(w)
}




#' Get joint probability of composition and moi
#' @param obj S4 object;
#' @param multi_dens parobability matrix; each row gives the probability density of
#'   each infection type for a given multiplicity of infection.
#' @param w numeric vector; probability (or weight) of each MOI scenario that was
#'        calculated by `moi_probabilities`

get_join_comp_moi_prob <- function(obj, multi_dens, w){

  checkclass(obj)
  assert_matrix(multi_dens)
  assert_vector(w)
  if(inherits(obj, "surveillance")){
   # theta <- 1 - sum(obj@cases)/obj@denominator
   prob.mat <- cbind(noinfxn = 0, multi_dens)
   prob.mat <- rbind(0, prob.mat)
   prob.mat[1,1] <- 1 # prob of MOI = 0 and no infxn

   prob.mat <- apply(prob.mat, 2, weighted.mean, w)

  } else if(inherits(obj, "casedetect")){
    prob.mat <- apply(multi_dens, 2, weighted.mean, w)
  }
  return(prob.mat)
}


#' likelihood function
#' @noRd

ll_function <- function(obj, params, data, pci_list,
                        density_func = independent,
                        max_moi = 25) {

  # pass the parameters to our density function
  probs <- density_func(obj, params, data, pci_list, max_moi)

  # calculate the log likelihood using the output multinomial prob distribution
  ll <- dmultinom(data, size = sum(data), prob = probs, log = TRUE)

  return(ll)

}




#' Co-occurence MLE
#'
#' Maximum likelihood estimation for co-infection dynamics
#' @param data Observed data. Either as a named vector or a 2 column
#'   \code{\link{data.frame}}. See examples for more info.
#' @param density_func Function that calculates the multinomial distribution
#'   describing the data. Default = \code{independent}
#' @param max_moi Maxuimum infction composition explored. Default = 25.
#' @param poisson Logical for determining if we use a poisson distribution to
#'   describe the numer of infection occurences. Default = `FALSE`, which means
#'   a negative binomial is used. `
#' @param size Starting value for the negative binomial size parameter.
#'   Default = 100.
#' @param boot_iter Bootstrap iterations. Default = 10000
#' @param plot Boolean for default plotting the bootsrap results. Default = TRUE
#' @param quantiles Vector of length 2 for the quantiles used. Default = `c(0.025, 0.975)`
#' @param lower Vector of lower bounds used in fitting. Default = NULL, which will
#'   create a vector with 0.0001 for each frequency and 0.1 for mu (and 1 for size).
#' @param upper Vector of upper bounds used in fitting. Default = NULL, which will
#'   create a vector with 0.9999 for each frequency and 100 for mu (and 500 for size).
#' @rdname cooccurence_mle
#'
#' @details Estimates the maximum likelihood population frequency of each species
#'   (i.e. the names of the observed entities in our data) and the mean number
#'   of infections given our observed data. These estimates are used to estimate
#'   the multinomial probability distribution.
#'
#' @return A list containing the estimated parameters.
#'
#' @export
#'

cooccurence_mle <- function(obj, density_func = independent,
                            max_moi = 25, poisson = FALSE,
                            size = 100, lower = NULL, upper = NULL,
                            boot_iter = 10000, plot = TRUE,
                            quantiles = c(0.025, 0.975),
                            ...) {
  # ----------------------------------------------------------------------------
  # format our input data
  # ----------------------------------------------------------------------------
  if(inherits(obj, "surveillance")){

    noinfxn <- obj@denominator - sum(obj@cases)
    real <- data.frame("variable" = c("noinfxn", obj@casenames),
                       "value" = c(noinfxn, obj@cases))

  } else if(inherits(obj, "casedetect")){

    real <- data.frame("variable" = obj@casenames,
                       "value" = obj@cases)
  }

  spcs <- obj@casenames[!grepl("/", obj@casenames)]
  # get start from data
  start <- sapply(spcs, function(x) {
    sum(real$value[grep(x, real$variable)])/sum(obj@cases)
  })

  # ----------------------------------------------------------------------------
  # create starting parameters
  # ----------------------------------------------------------------------------
  # add mean number of infxns
  # add any additonal parameters that need to be fit relevant to model
  start <- c( start, "mu" = 2, ...)

  # check on bounds
  if (is.null(lower)) {
    lower <- c(rep(0.0001, (length(start)-1)), mu = 0.1)
  }

  if (is.null(upper)) {
    upper <- c(rep(0.9999, (length(start)-1)), mu = 1e2)
  }

  # are we using a poisson or neg binomial for infections
  if (!poisson) {
    start <- c(start, "size" = size)
    lower <- c(lower, "size" = 1)
    upper <- c(upper, "size" = 500)
  }

  # get marginal number of species for perms
  freq_length <- sum(!grepl("/|noinfxn", real$variable))

  # ----------------------------------------------
  # create permutation objects once here for speed
  # ----------------------------------------------
  # generate our moi permutations once here and pass as extra argument
  perms <- lapply(1:max_moi, FUN = moi_perms, n = freq_length)

  # and also set up the list of types of infection status from this
  comps <- generate_composition_levels(names = obj@casenames[!grepl("/", obj@casenames)])

  # and order our data passed in this way and fill in blanks
  dat <- obj@cases
  names(dat) <- obj@casenames
  dat <- dat[match(comps, names(dat))]
  dat[is.na(dat)] <- 0
  if(inherits(obj, "surveillance")){
    dat <- c(obj@denominator - sum(obj@cases), dat)
    names(dat)[1] <- "noinfxn"
  }


  # lastly for each infection permutation what is the observed infection
  infs <- find_composition_level(nms = obj@casenames[!grepl("/", obj@casenames)],
                                 perms = perms)

  pci_list <- list("perms" = perms, "comps" = comps, "infs" = infs)

  # ----------------------------------------------
  # model fitting
  # ----------------------------------------------

  # fit our best model
  fit <- optim(
    obj = obj,
    par = start,
    fn = ll_function,
    data = dat,
    pci_list = pci_list,
    density_func = density_func,
    max_moi = max_moi,
    method = "L-BFGS-B",
    lower = lower,
    upper = upper,
    control = list(
      trace = TRUE,
      fnscale = -1,
      maxit = 10000
    ),
    hessian = TRUE
  )

  # work out what the resultant multinomial distribution was
  fitted_multinomial <- density_func(obj = obj,
                                     params = fit$par,
                                     data = dat,
                                     pci_list = pci_list,
                                     max_moi = max_moi)


  # create the bootstrapped coinf plot
  coinf <- coinf_plot(
    reps = boot_iter,
    probs = fitted_multinomial ,
    levels = names(fitted_multinomial),
    total = sum(dat),
    plot = plot,
    real = real
  )

  # remember to format the probabilities so they add to 1 for reporting reasons
  # freqs <- fit$par[1:freq_length]
  # freqs <- freqs / sum(freqs)
  # fit$par[1:freq_length] <- freqs
  # TODO talk about if we should overwrite the fit here
  # or if we have enough info already with the multinomial fit return


  ret <- list("multinom" = fitted_multinomial,
              "fit" = fit,
              "pci_list" = pci_list,
              "data" = data,
              "coinfxnplot" = coinf)

  return(ret)
}

